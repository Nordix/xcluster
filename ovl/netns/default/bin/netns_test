#! /bin/sh
##
## netns_test --
##
##   Test script for netns executed in xcluster.
##
## Commands;
##

prg=$(basename $0)
dir=$(dirname $0); dir=$(readlink -f $dir)
me=$dir/$prg
tmp=/tmp/${prg}_$$
test -r /etc/profile && . /etc/profile

test -n "$ADRTEMPLATE" || ADRTEMPLATE=172.16.0.0/16/24
test -n "$NPODS" || NPODS=4
test -n "$PREFIX" || PREFIX=1000::1
test -n "$PODIF" || PODIF=eth0
die() {
	echo "ERROR: $*" >&2
	rm -rf $tmp
	exit 1
}
help() {
	grep '^##' $0 | cut -c3-
	rm -rf $tmp
	exit 0
}
test -n "$1" || help
echo "$1" | grep -qi "^help\|-h" && help

log() {
	echo "$prg: $*" >&2
}
dbg() {
	test -n "$__verbose" && echo "$prg: $*" >&2
}

## Test-cases;
##   Used environment variables with defaults;
##     NPODS=4
##     ADRTEMPLATE=172.16.0.0/16/24
##     PREFIX=1000::1
##

##   version -- Log version
cmd_tcase_version() {
	log_version
}
##   cni_bridge_configure -- Configure CNI-bridge
cmd_tcase_cni_bridge_configure() {
	tcase "Setup CNI-bridge. Template [$ADRTEMPLATE]"
	cmd_cni_bridge_configure $ADRTEMPLATE
}
##   cni_bridge_start -- Create netns using CNI-bridge
cmd_tcase_cni_bridge_start() {
	tcase "Start PODs with CNI-bridge [$NPODS]"
	cmd_create $NPODS
	cmd_cni_bridge_start $NPODS
}
##   cni_bridge_ping -- Ping local PODs from main netns
cmd_tcase_cni_bridge_ping() {
	local acount=$(cat /tmp/$(hostname)-ns* | jq -r .ips[].address | wc -l)
	tcase "Ping $acount local netns addresses"
	local a adr
	for a in $(cat /tmp/$(hostname)-ns* | jq -r .ips[].address); do
		#tlog "Ping $a"
		adr=$(echo $a | cut -d/ -f1)
		tex ping -c1 -W1 $adr || tdie "Ping $adr"
	done
}
##   create - Create $NPODS PODs
cmd_tcase_create() {
	tcase "Create PODs [$NPODS]"
	cmd_create $NPODS
}
##   create_veth - Create VETH pairs to PODs
cmd_tcase_create_veth() {
	tcase "Create VETH pairs to PODs"
	cmd_veth $NPODS
}
##   create_with_addresses - Create PODs and assign addresses
cmd_tcase_create_with_addresses() {
	tcase "Create PODs and assign addresses [$NPODS]"
	cmd_create $NPODS
	cmd_veth $NPODS
	cmd_assign_addresses $ADRTEMPLATE $NPODS	
}
##   linux_bridge - Create a Linux bridge and connect PODs
cmd_tcase_linux_bridge() {
	tcase "Create a Linux bridge and connect PODs"
	test -n "$BR" || BR=br0
	ip link add name $BR type bridge || tdie
	cmd_assign_bridge_address $ADRTEMPLATE $BR
	__defaultgw=yes
	cmd_connect_to_bridge $BR $NPODS
}
##   bridge_ping -- Ping local PODs from main netns
cmd_tcase_bridge_ping() {
	tcase "Ping local netns addresses"
	local pod adr
	for pod in $(cmd_name $NPODS); do
		for adr in $(cmd_compute_address $ADRTEMPLATE $pod | cut -d/ -f1); do
			#tlog "Ping $adr"
			tex ping -c1 -W1 $adr || tdie "Ping $adr"
		done
	done
}


##
## Commands on nodes;

# Netns init command
cmd_init() {
	hostname $1
	ip link set up dev lo
	#nc -p 7777 -lk -e hostname & # NO! Keep-it-simple
}

##   prerequisites
##     Check prerequisites. Only the "ipu" program for now.
cmd_prerequisites() {
	if ! which ipu > /dev/null; then
		cat >&2 <<"EOF"
The "ipu" utility must be included. It is a part of
https://github.com/Nordix/nfqueue-loadbalancer/. Download a
release and set $NFQLBDIR to point to it.
EOF
		die "Missing; ipu"
	fi
}
##   for [count] [first]
##     Emit a sequence of <count> numbers starting with <first>
cmd_for() {
	local count=1
	test -n "$1" && count=$1
	local first=1
	test -n "$2" && first=$2
	local n
	for n in $(seq $count); do
		echo $((first + n - 1))
	done
}

##   name [count] [first]
##     Print netns names
cmd_name() {
	local n
	for n in $(cmd_for $1 $2); do
		printf "%s-ns%02d\n" $(hostname) $n
	done
}

##   create [count] [first]
##     Create network namespaces
cmd_create() {
	mkdir -p /var/run/utsns
	local name
	for name in $(cmd_name $1 $2); do
		ip netns add $name || die
		touch /var/run/utsns/$name
		unshare --net=/var/run/netns/$name --uts=/var/run/utsns/$name \
			$me init $name
	done
}

##   veth [count] [first]
##     Create veth to PODs. Link is "up" and "dad" disabled
cmd_veth() {
	local name
	for name in $(cmd_name $1 $2); do
		ip link add $name type veth peer name host || die
		ip link set netns $name dev host || die
		test "$PODIF" != "host" && \
			ip -n $name link set name $PODIF dev host
		sysctl -qw net.ipv6.conf.$name.accept_dad=0 || die
		ip link set up dev $name || die
		ip netns exec $name sysctl -qw net.ipv6.conf.$PODIF.accept_dad=0 || die
		ip -n $name link set up dev $PODIF || die
	done
}

##   exec pod command args...
##     Execute a command in a POD
cmd_exec() {
	test -n "$1" || die "No pod"
	local name=$1
	shift
	nsenter -n/var/run/netns/$name -u/var/run/utsns/$name $@
}

##   compute_address [--family=4|6] <addr-template> <pod>
##     Compute the addresses for a POD
cmd_compute_address() {
	test -n "$2" || die "Params missing"
	cmd_prerequisites
	local ipu_params=$(echo $2 | sed -E 's,vm-0*([0-9]+)-ns0*([0-9]+),--net=\1 --host=\2,')
	test "$__family" != 6 && \
		ipu makeip --cidr=$1 $ipu_params --subnet=2
	test "$__family" != 4 && \
		ipu makeip --cidr=$1 $ipu_params --subnet=2 --ipv6template=$PREFIX:0.0.0.0
	return 0
}

##   assign_addresses <addr-template> [count] [first]
##     Assign addresses to PODs
cmd_assign_addresses() {
	local pod adr
	test -n "$1" || die "No addr-template"
	for pod in $(cmd_name $2 $3); do
		for __family in 4 6; do
			adr=$(cmd_compute_address $1 $pod)
			ip -$__family -n $pod addr replace $adr dev $PODIF
		done
	done
}
##   cni_bridge_configure <address-template>
##     Configure CNI-bridge
cmd_cni_bridge_configure() {
	test -n "$1" || die "No address"
	cmd_prerequisites
	test -x /opt/cni/bin/bridge || die "CNI-plugins not included"
	local ipv4=$(ipu makeip --cidr=$1 --net=$(mynode) --subnet=2)
	local ipv6=$(ipu makeip --cidr=$1 --net=$(mynode) --subnet=2 --ipv6template=$PREFIX:0.0.0.0)
	mkdir -p /etc/cni/net.d
	cat > /etc/cni/10-bridge.conf <<EOF
{
    "cniVersion": "1.0.0",
    "name": "xnet",
    "type": "bridge",
    "isDefaultGateway": true,
    "hairpinMode": true,
    "ipam": {
      "type": "host-local",
      "ranges": [
        [ { "subnet": "$ipv4" } ],
        [ { "subnet": "$ipv6" } ]
      ]
    }
}
EOF
}

##   cni_bridge_start [count]
##     Setup addresses for PODs using CNI-bridge . Logs like /tmp/vm-001-ns01.json
cmd_cni_bridge_start() {
	test -r /etc/cni/10-bridge.conf || die "Bridge not configured"
	local count=1
	test -n "$1" && count=$1
	local n
	# This takes an age so do it in parallel
	for n in $(netns_test name $count); do
		# These takes >1s (because of DAD) so execute in parallel
		CNI_CONTAINERID=$n CNI_NETNS=/var/run/netns/$n CNI_IFNAME=$PODIF \
			CNI_PATH=/opt/cni/bin CNI_COMMAND=ADD /opt/cni/bin/bridge \
			< /etc/cni/10-bridge.conf > /tmp/$n.json &
	done
	wait
}

##   assign_bridge_address <address-template> <device>
##     Assign addresses to a bridge and set default route in PODs
cmd_assign_bridge_address() {
	test -n "$2" || die "Param missing"
	cmd_prerequisites
	local adrtempl=$1
	local br=$2
	sysctl -qw net.ipv6.conf.$br.accept_dad=0 || die
	ip link set up dev $br || die
	local adr mynode
	mynode=$(mynode)

	adr=$(ipu makeip --cidr=$adrtempl --net=$(mynode) --subnet=2)
	ip addr replace $adr dev $br || die

	adr=$(ipu makeip --cidr=$adrtempl --net=$(mynode) --subnet=2 --ipv6template=$PREFIX:0.0.0.0)
	ip -6 addr replace $adr dev $br || die
}

##   connect_to_bridge [--defaultgw] <device> [count] [first]
##     Connect PODs to a bridge. Optionally set default route in PODs,
cmd_connect_to_bridge() {
	test -n "$1" || die "Param missing"
	local pod br=$1
	for pod in $(cmd_name $2 $3); do
		ip link set dev $pod master $br || tdie
	done

	test "$__defaultgw" = "yes" || return 0

	local adr family
	for adr in $(ip -j addr show dev $br | \
		jq -r '.[]|select(.addr_info)|.addr_info[]|select(.scope == "global")|.local'); do
		family=4
		echo $adr | grep -q : && family=6
		for pod in $(cmd_name $2 $3); do
			ip -$family -n $pod route replace default via $adr || die $adr
		done
	done
}


test -r /usr/lib/xctest && . /usr/lib/xctest
indent='  '

##
# Get the command
cmd=$1
shift
grep -q "^cmd_$cmd()" $0 || die "Invalid command [$cmd]"

while echo "$1" | grep -q '^--'; do
	if echo $1 | grep -q =; then
		o=$(echo "$1" | cut -d= -f1 | sed -e 's,-,_,g')
		v=$(echo "$1" | cut -d= -f2-)
		eval "$o=\"$v\""
	else
		o=$(echo "$1" | sed -e 's,-,_,g')
		eval "$o=yes"
	fi
	shift
done
unset o v
long_opts=`set | grep '^__' | cut -d= -f1`

# Execute command
trap "die Interrupted" INT TERM
cmd_$cmd "$@"
status=$?
rm -rf $tmp
exit $status
